const cron = require('node-cron');
const moment = require('moment-timezone');
const axios = require('axios');
const prisma = require('./lib/prisma');

// –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é retrySubscription –∏–∑ retryController
const { retrySubscription } = require('./controllers/retryController');

// –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —É—Ç–∏–ª–∏—Ç—ã –∏–∑ schedulerController
const { getTimezoneByCountry, computeLocalAt } = require('./controllers/schedulerController');

// --- Utilities ----------------------------------------------------------------

function computeNextRecurringAt(createdAt, timezone) {
  // –ü–µ—Ä–≤—ã–π —Ä–µ–±–∏–ª–ª —á–µ—Ä–µ–∑ 7 –¥–Ω–µ–π, –≤ 23:30 –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const base = moment(createdAt).tz(timezone).add(7, 'days').hour(23).minute(30).second(0).millisecond(0);
  return base.toDate();
}

// --- Core ---------------------------------------------------------------------

async function attemptRebill(payment) {
  try {
    console.log(`üîÑ Attempting rebill for payment ${payment.id}`);

    // –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥: —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º retry —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º referenceCode
    if (payment.subscriptionReferenceCode) {
      console.log(`üîÑ Trying retry with existing referenceCode: ${payment.subscriptionReferenceCode}`);
      
      try {
        const retryResult = await retrySubscription(payment.subscriptionReferenceCode);
        
        if (retryResult.success) {
          // –£—Å–ø–µ—Ö retry: –æ—Ç–∫–ª—é—á–∞–µ–º –¥–∞–ª—å–Ω–µ–π—à–∏–µ –ø–æ–ø—ã—Ç–∫–∏ –∏ —Å—Ç–∞–≤–∏–º —Å–ª–µ–¥—É—é—â—É—é –¥–∞—Ç—É —á–µ—Ä–µ–∑ 7 –¥–Ω–µ–π
          const tz = payment.timezone || getTimezoneByCountry(payment.countryCode);
          const nextAt = computeNextRecurringAt(new Date(), tz);
          await prisma.payment.update({
            where: { id: payment.id },
            data: {
              lastAttemptAt: new Date(),
              rebillAttempts: (payment.rebillAttempts || 0) + 1,
              nextRecurringAt: nextAt,
              isRecurringActive: true,
              rebillLog: [
                ...(payment.rebillLog || []),
                {
                  status: 'success',
                  at: new Date().toISOString(),
                  stage: 'retry-success',
                  raw: retryResult,
                }
              ],
            },
          });
          console.log(`‚úÖ Retry succeeded for ${payment.id}`);
          return true;
        } else {
          console.log(`‚ö†Ô∏è Retry failed for ${payment.id}: ${retryResult.error}. Falling back to new subscription.`);
        }
      } catch (retryError) {
        console.log(`‚ö†Ô∏è Retry error for ${payment.id}: ${retryError.message}. Falling back to new subscription.`);
      }
    }

    // Fallback: —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É —á–µ—Ä–µ–∑ /pay
    console.log(`üîÑ Creating new subscription for payment ${payment.id}`);
    
    const payload = {
      firstName: payment.firstName,
      lastName: payment.lastName,
      email: payment.email,
      phone: payment.phone,
      countryCode: payment.countryCode,
      address: payment.address,
      postalCode: payment.postalCode,
      city: payment.city,
      cardHolder: payment.cardHolder,
      cardNumber: payment.cardNumber,
      expiry: payment.expiry,
      cvv: payment.cvv,
      plan: payment.plan,
      bid: payment.bid,
      userHash: payment.userHash,
      locale: payment.locale,
      isRecurring: true,
    };

    const response = await axios.post('http://localhost:3011/pay', payload, {
      headers: { 'Content-Type': 'application/json' },
      timeout: 60_000,
    });

    const ok = !!response?.data?.success;
    const isInsufficient = (() => {
      const msg = (response?.data?.errorMessage || '').toString().toLowerCase();
      const code = (response?.data?.errorCode || '').toString().toLowerCase();
      return msg.includes('insufficient') || code.includes('insufficient');
    })();

    if (ok) {
      // –£—Å–ø–µ—Ö: –æ—Ç–∫–ª—é—á–∞–µ–º –¥–∞–ª—å–Ω–µ–π—à–∏–µ –ø–æ–ø—ã—Ç–∫–∏ –∏ —Å—Ç–∞–≤–∏–º —Å–ª–µ–¥—É—é—â—É—é –¥–∞—Ç—É —á–µ—Ä–µ–∑ 7 –¥–Ω–µ–π
      const tz = payment.timezone || getTimezoneByCountry(payment.countryCode);
      const nextAt = computeNextRecurringAt(new Date(), tz);
      await prisma.payment.update({
        where: { id: payment.id },
        data: {
          subscriptionReferenceCode: response.data.firstReferenceCode || payment.subscriptionReferenceCode,
          lastAttemptAt: new Date(),
          rebillAttempts: (payment.rebillAttempts || 0) + 1,
          nextRecurringAt: nextAt,
          isRecurringActive: true,
          rebillLog: [
            ...(payment.rebillLog || []),
            {
              status: 'success',
              at: new Date().toISOString(),
              stage: 'new-subscription-success',
              raw: response.data,
            }
          ],
        },
      });
      console.log(`‚úÖ New subscription succeeded for ${payment.id}`);
      return true;
    }

    // –û—à–∏–±–∫–∞: –µ—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ ‚Äî –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ 1 –¥–µ–Ω—å, –∏–Ω–∞—á–µ –ø—Ä–µ–∫—Ä–∞—â–∞–µ–º –ø–æ–ø—ã—Ç–∫–∏
    const tz = payment.timezone || getTimezoneByCountry(payment.countryCode);
    const retryAt = moment().tz(tz).add(1, 'day').hour(23).minute(30).second(0).millisecond(0).toDate();
    const updateData = {
      lastAttemptAt: new Date(),
      rebillAttempts: (payment.rebillAttempts || 0) + 1,
      rebillLog: [
        ...(payment.rebillLog || []),
        {
          status: 'failure',
          at: new Date().toISOString(),
          stage: 'new-subscription-failure',
          error: {
            code: response?.data?.errorCode,
            message: response?.data?.errorMessage || response?.statusText,
            group: response?.data?.errorGroup,
            errors: response?.data?.errors,
          },
        }
      ],
    };
    if (isInsufficient) {
      updateData.nextRecurringAt = retryAt;
      updateData.isRecurringActive = true;
      console.warn(`‚ö†Ô∏è New subscription failed (insufficient funds) for ${payment.id}. Next attempt at ${retryAt.toISOString()}`);
    } else {
      updateData.nextRecurringAt = null;
      updateData.isRecurringActive = false;
      console.warn(`‚õî New subscription failed (non-retryable) for ${payment.id}. Disabling further attempts.`);
    }
    await prisma.payment.update({ where: { id: payment.id }, data: updateData });
    return false;
  } catch (error) {
    console.error(`‚ùå Rebill error for ${payment.id}:`, error.message);
    // –î–ª—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏ ‚Äî –Ω–µ –∑–Ω–∞–µ–º —Ç–∏–ø, –ø–æ–≤—Ç–æ—Ä–∏–º —á–µ—Ä–µ–∑ 1 –¥–µ–Ω—å
    const tz = payment.timezone || getTimezoneByCountry(payment.countryCode);
    const retryAt = moment().tz(tz).add(1, 'day').hour(23).minute(30).second(0).millisecond(0).toDate();
    await prisma.payment.update({ where: { id: payment.id }, data: {
      lastAttemptAt: new Date(),
      rebillAttempts: (payment.rebillAttempts || 0) + 1,
      nextRecurringAt: retryAt,
      isRecurringActive: true,
      rebillLog: [
        ...(payment.rebillLog || []),
        { 
          status: 'failure', 
          at: new Date().toISOString(),
          stage: 'technical-error',
          error: { message: error.message } 
        }
      ],
    }});
    return false;
  }
}

async function processRecurringPayments() {
  console.log('üïê Scanning for due rebills...');
  const now = new Date();
  // –û–∫–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏: —Ç–æ–ª—å–∫–æ –∑–∞–ø–∏—Å–∏, —É –∫–æ—Ç–æ—Ä—ã—Ö nextRecurringAt –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [now-15m; now]
  const windowStart = new Date(now.getTime() - 15 * 60 * 1000);
  const due = await prisma.payment.findMany({
    where: {
      isRecurringActive: true,
      nextRecurringAt: { lte: now, gt: windowStart },
    },
    orderBy: { nextRecurringAt: 'asc' },
    take: 200,
  });

  console.log(`üìä Found ${due.length} payments to process`);
  for (const p of due) {
    await attemptRebill(p);
  }
}

// --- Scheduler ----------------------------------------------------------------

let schedulerStarted = false;

function startPaymentScheduler() {
  if (schedulerStarted) return;
  schedulerStarted = true;

  console.log('üöÄ Starting recurring payment scheduler...');

  // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª: –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç, —á—Ç–æ–±—ã –ø–æ–ø–∞—Å—Ç—å –≤ –æ–∫–Ω–æ 23:30‚Äì23:55
  cron.schedule('*/5 * * * *', async () => {
    await processRecurringPayments();
  });

  console.log('‚úÖ Scheduler running. Interval: every 5 minutes');
}

// --- DB Triggers (lightweight) -----------------------------------------------

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –≤—ã–∑—ã–≤–∞—Ç—å –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö –≤ –ë–î (—Å–æ–∑–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã –∏ —Ç.–ø.)
// –ú–æ–∂–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ –≤—ã–∑—ã–≤–∞—Ç—å –∏–∑ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–ø–∏—Å–∏
async function notifyDbChanged() {
  // –õ—ë–≥–∫–∏–π –¥–µ–±–∞—É–Ω—Å, —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å
  if (notifyDbChanged.lock) return;
  notifyDbChanged.lock = true;
  setTimeout(() => (notifyDbChanged.lock = false), 5_000);
  await processRecurringPayments();
}

// --- Initial backfill for existing records -----------------------------------

async function ensureNextRecurringForNewPayments() {
  // –î–ª—è –∑–∞–ø–∏—Å–µ–π, –≥–¥–µ nextRecurringAt –ø—É—Å—Ç, –ø—Ä–æ—Å—Ç–∞–≤–∏–º –≤–ø–µ—Ä–≤—ã–µ
  const candidates = await prisma.payment.findMany({
    where: { nextRecurringAt: null },
    take: 500,
  });

  for (const p of candidates) {
    const tz = p.timezone || getTimezoneByCountry(p.countryCode);
    const nextAt = computeNextRecurringAt(p.createdAt, tz);
    await prisma.payment.update({ where: { id: p.id }, data: { timezone: tz, nextRecurringAt: nextAt } });
  }
}

module.exports = {
  startPaymentScheduler,
  processRecurringPayments,
  notifyDbChanged,
  ensureNextRecurringForNewPayments,
};

// –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –ø—Ä–∏ –ø—Ä—è–º–æ–º –≤—ã–∑–æ–≤–µ
if (require.main === module) {
  (async () => {
    await ensureNextRecurringForNewPayments();
    startPaymentScheduler();
    await processRecurringPayments();
  })();
}
